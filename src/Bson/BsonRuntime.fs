(* Copyright (c) 2013-2014 Tomas Petricek and Gustavo Guerra
 * Copyright (c) 2014 Max Hirschhorn
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *)

// -----------------------------------------------------------------------------
// BSON type provider - methods that are called from the generated erased code
// -----------------------------------------------------------------------------

namespace BsonProvider.Runtime

open System
open System.ComponentModel
open System.IO
open MongoDB.Bson
open MongoDB.Bson.Serialization
open FSharp.Data.Runtime.StructuralTypes

#nowarn "10001"

/// [omit]
type IBsonTop =
    abstract BsonValue : BsonValue

    [<EditorBrowsableAttribute(EditorBrowsableState.Never)>]
    [<CompilerMessageAttribute("This method is intended for use in generated code only.", 10001, IsHidden=true, IsError=false)>]
    abstract Path : unit -> string

    [<EditorBrowsableAttribute(EditorBrowsableState.Never)>]
    [<CompilerMessageAttribute("This method is intended for use in generated code only.", 10001, IsHidden=true, IsError=false)>]
    abstract Create : value:BsonValue * pathIncrement:string -> IBsonTop

/// Underlying representation of types generated by BsonProvider
[<StructuredFormatDisplay("{_Print}")>]
type BsonTop =
    private {
        /// [omit]
        Value : BsonValue
        /// [omit]
        Path : string
    }

    interface IBsonTop with
        member x.BsonValue = x.Value
        member x.Path() = x.Path
        member x.Create(value, pathIncrement) =
            BsonTop.Create(value, x.Path + pathIncrement)

    /// The underlying BsonValue
    member x.BsonValue = x.Value

    /// [omit]
    [<EditorBrowsableAttribute(EditorBrowsableState.Never)>]
    [<CompilerMessageAttribute("This method is intended for use in generated code only.", 10001, IsHidden=true, IsError=false)>]
    member x._Print = x.Value.ToString()

    /// [omit]
    [<EditorBrowsableAttribute(EditorBrowsableState.Never)>]
    [<CompilerMessageAttribute("This method is intended for use in generated code only.", 10001, IsHidden=true, IsError=false)>]
    override x.ToString() = x._Print

    /// [omit]
    [<EditorBrowsableAttribute(EditorBrowsableState.Never)>]
    [<CompilerMessageAttribute("This method is intended for use in generated code only.", 10001, IsHidden=true, IsError=false)>]
    static member Create(value, path) =
        { Value = value
          Path = path } :> IBsonTop

    /// [omit]
    [<EditorBrowsableAttribute(EditorBrowsableState.Never)>]
    [<CompilerMessageAttribute("This method is intended for use in generated code only.", 10001, IsHidden=true, IsError=false)>]
    static member Parse(stream:Stream) =
        seq {
            use stream = stream
            while stream.Position <> stream.Length do
                yield BsonSerializer.Deserialize<BsonDocument>(stream)
        }

    /// [omit]
    [<EditorBrowsableAttribute(EditorBrowsableState.Never)>]
    [<CompilerMessageAttribute("This method is intended for use in generated code only.", 10001, IsHidden=true, IsError=false)>]
    static member CreateList(stream:Stream) =
        BsonTop.Parse stream
        |> Seq.mapi (fun i value -> BsonTop.Create(value, sprintf "[%d]" i))
        |> Seq.toArray

/// Static helper methods called from the generated code for working with BSON
type BsonRuntime =

    // -------------------------------------------------------------------------
    // bson option -> type
    // -------------------------------------------------------------------------

    static member ConvertBoolean = Option.bind BsonConversions.AsBoolean

    static member ConvertInteger = Option.bind BsonConversions.AsInteger

    static member ConvertInteger64 = Option.bind BsonConversions.AsInteger64

    static member ConvertFloat = Option.bind BsonConversions.AsFloat

    static member ConvertString = Option.bind BsonConversions.AsString

    static member ConvertDateTime = Option.bind BsonConversions.AsDateTime

    static member ConvertObjectId = Option.bind BsonConversions.AsObjectId

    /// Operation that extracts the value from an option and reports a meaningful
    /// error message when the value is not present.
    static member GetNonOptionalValue<'T>(path:string, opt:option<'T>, value:BsonValue option) : 'T =
        match opt, value with
        | Some x, _ -> x
        | None, None -> failwithf "'%s' is missing" path
        | None, Some x -> failwithf "Expecting %A at '%s', but received %A" typeof<'T> path x

    /// Convert BSON array to array of target types
    static member ConvertArray<'T>(top:IBsonTop, mapping:Func<IBsonTop,'T>) =
        match top.BsonValue.BsonType with
        | BsonType.Array ->
            top.BsonValue.AsBsonArray.Values
            |> Seq.filter (fun value ->
                match value.BsonType with
                | BsonType.Null -> false
                | _ -> true)
            |> Seq.mapi (fun i value -> top.Create(value, sprintf "[%d]" i))
            |> Seq.map mapping.Invoke
            |> Seq.toArray

        | BsonType.Null -> [| |]
        | _ -> failwithf "Expecting a list at '%s', got %A" (top.Path()) top

    static member ConvertArray(top) =
        BsonRuntime.ConvertArray<IBsonTop>(top, Func<_,_> id)

    /// Convert BSON array to array of target types
    static member ConvertArrayOfOptionals<'T>(top:IBsonTop, mapping:Func<IBsonTop,'T>) =
        match top.BsonValue.BsonType with
        | BsonType.Array ->
            top.BsonValue.AsBsonArray.Values
            |> Seq.map (fun value ->
                match value.BsonType with
                | BsonType.Null
                | BsonType.Undefined -> None
                | _ -> Some value)
            |> Seq.mapi (fun i value ->
                let create value = top.Create(value, sprintf "[%d]" i)
                Option.map create value)
            |> Seq.map (Option.map mapping.Invoke)
            |> Seq.toArray

        | BsonType.Null -> [| |]
        | _ -> failwithf "Expecting a list at '%s', got %A" (top.Path()) top

    /// Optionally get property of BsonDocument
    static member TryGetPropertyUnpacked(top:IBsonTop, name) =
        match top.BsonValue.BsonType with
        | BsonType.Document ->
            let doc = top.BsonValue.AsBsonDocument
            if doc.Contains name then
                let value = doc.GetValue name
                match value.BsonType with
                | BsonType.Null -> None
                | _ -> Some value
            else None
        | _ -> None

    /// Optionally get property wrapped in a BsonTop
    static member TryGetPropertyPacked(top:IBsonTop, name) =
        BsonRuntime.TryGetPropertyUnpacked(top, name)
        |> Option.map (fun value -> top.Create(value, sprintf "/%s" name))

    /// Get property wrapped in a BsonTop
    static member GetPropertyPacked(top:IBsonTop, name) =
        match BsonRuntime.TryGetPropertyPacked(top, name) with
        | Some top -> top
        | None -> failwithf "Property '%s' not found at '%s': %A" name (top.Path()) top

    /// Get property wrapped in a BsonTop, returns null if not found
    static member GetPropertyPackedOrNull(top:IBsonTop, name) =
        match BsonRuntime.TryGetPropertyPacked(top, name) with
        | Some top -> top
        | None -> top.Create(BsonNull.Value, sprintf "/%s" name)

    /// Optionally get property and convert it to the specified type
    static member ConvertOptionalProperty<'T>(top:IBsonTop, name, mapping:Func<IBsonTop,'T>) =
        BsonRuntime.TryGetPropertyPacked(top, name)
        |> Option.map mapping.Invoke

    /// Converts an object to a BsonValue
    static member private ToBsonValue (value:obj) =
        let inline optionToBson f = function
            | None -> BsonNull.Value :> BsonValue
            | Some v -> f v :> BsonValue

        match value with
        | null -> BsonNull.Value :> BsonValue

        | :? IBsonTop as v -> v.BsonValue
        | :? Array as v ->
            BsonArray [| for elem in v -> BsonRuntime.ToBsonValue elem |] :> BsonValue

        // primitive types
        | :? string    as v -> BsonString v :> BsonValue
        | :? DateTime  as v -> BsonDateTime v :> BsonValue
        | :? int       as v -> BsonInt32 v :> BsonValue
        | :? int64     as v -> BsonInt64 v :> BsonValue
        | :? float     as v -> BsonDouble v :> BsonValue
        | :? bool      as v -> BsonBoolean v :> BsonValue
        | :? BsonValue as v -> v

        // option types
        | :? option<string>    as v -> optionToBson (fun x -> BsonString x) v
        | :? option<DateTime>  as v -> optionToBson (fun (x : DateTime) -> BsonDateTime x) v
        | :? option<int>       as v -> optionToBson (fun x -> BsonInt32 x) v
        | :? option<int64>     as v -> optionToBson (fun x -> BsonInt64 x) v
        | :? option<float>     as v -> optionToBson (fun x -> BsonDouble x) v
        | :? option<bool>      as v -> optionToBson (fun x -> BsonBoolean x) v
        | :? option<BsonValue> as v -> optionToBson id v

        | _ -> failwithf "Cannot create BsonValue from %A" value

    /// Creates a BsonValue wrapped in a BsonTop
    static member CreateValue value =
        let bson = BsonRuntime.ToBsonValue value
        BsonTop.Create(bson, "")

    /// Creates a BsonDocument wrapped in a BsonTop
    static member CreateDocument properties =
        let value =
            properties
            |> Array.map (fun (k, v) -> BsonElement(k, BsonRuntime.ToBsonValue v))
            |> Array.toSeq
        BsonTop.Create(BsonDocument value, "")

    /// Creates a BsonArray wrapped in a BsonTop
    static member CreateArray elements =
        let value =
            elements
            |> Array.collect (BsonRuntime.ToBsonValue >> (fun value ->
                match value.BsonType with
                | BsonType.Array -> Array.ofSeq value.AsBsonArray.Values
                | BsonType.Null -> [| |]
                | _ -> [| value |]))
        BsonTop.Create(BsonArray value, "")
